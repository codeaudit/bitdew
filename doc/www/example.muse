#title A Tutorial for BitDew Attributes 
#author Gilles Fedak
#desc BitDew: a Programmable Environment for Data Desktop Grids

<contents>

* Description of Data Attributes 


The key features of the BitDew is the ability to hide the complexity
of managing data in highly dynamic system by allowing the programmer to specify  for each data the data attributes.
The runtime environment interprets these attributes and tries to answer this
in a best-effort way.  The following is the list of attributes a user can set:


*i) replicata:*  gives the number of instances of a data that should exist of the same time in the network. The runtime environment will schedule new data transfers to hosts in order to satisfy at minima this constraint. As nodes are volatile there might be more replicas in the system than what is specified by this attribute, as the runtime environment will not issue orders for data deletion.

*ii) fault-tolerance* indicates what the runtime environment should do in the presence of a crash of a machine holding the data. If the data is marked as persistent, the data will be attributed to another node so that the number of replicas is kept constant over time. If the data is marked as volatile, the data will not be rescheduled in the case of a fault.

*iii) lifetime:* defines either absolute lifetime, expressed in hours, or relative lifetime according to existence of another data. In the latter case, a data will cease to exist in the system when the reference data disappears. A configurable system-wide absolute lifetime is the default mode when nothing else is specified.

*iv) affinity:* defines the dependency among the data. It indicates that data should be placed on a node where other data had been previously sent. Placement is an order stronger than replica. For instance if data A is *r* replica and is distributed to *n* nodes, then if a data B has a placement dependency over A, it will be replicated over *n* nodes.

*v) distribution protocol:* specifies to the runtime environment the prefered protocol to use to distribute the data. Users are more knowledgeable to select the most appropriate protocol according to their own criteria like the size of data and the number of nodes to distribute these data.  For example a large file distributed to a large number of nodes would be preferably distributed using BitTorrent protocol.

Programmers define for every data these simple criteria, and let the BitDew runtime environment manage operations of data creation, deletion, movement, replication, and fault-tolerance
operation.

** Summary of the attributes and their values




attribute || flag | value || comments

replicat  | false | 1 (default)    | default value
replicat  | true  |      | data present on n hosts simulatenoulsy (best effort)
replicat  | -1    | present on every host



fault-tolerance | false (default) | the data is volatile, it will not be rescheduled if the host fails
fault-tolerance | true | the data is scheduled to an other host if it one containing the data fails           


lifetime  |  d (date) | will be deleted when the lifetime has expired
lifetime  | uuid  | will deleted when the data of uuid is deleted

affinity  | uuid  | data will be present where data uuid is present


protocol  | name   | name of the protocol prefered to distribute the data


* Use case : Programing a Master/worker Application


As an example, we present a simple Master/worker application very common in the scientific world, and we show how to use Bitdew to develop this. The application is based on NCBI BLAST (Basic Local Alignment Search Tool),  BLAST compares a query sequence with a database of sequences, and identifies library sequences that resemble the query sequence above a certain threshold. In our experiments, we used the *blastp* program that compares an amino acid query sequence against a protein sequence database. The input DNA sequences used were taken from the GenBank database and the DNA databases were taken from The National Center for Biotechnology Information.


In a classical MW application, tasks are created by the master and scheduled to the workers. Once a task is scheduled, the worker has to download the data needed before the task is executed. In contrast, the data-driven approach followed by Bitdew implies that data are first scheduled to hosts. The programmer do not have to code explicitly the data movement from host to host, neither to manage fault tolerance. Programming the master or the worker consists in operating on  data and attributes and reacting on data events such as creation, deletion, movement.

** Application deployment

With this application, there exists three sets of data : the application files, the database files, and the sequence files. The application file is a binary files which has to be deployed on each node of the network. The replication attribute is set to -1, which is a special value which indicates that the data will be transfered to every node in the network. As the file will be distributed to a large number of nodes, we indicate to the runtime that a BitTorrent is the prefered protocol to distribute this data. We call this attribute the Blast attribute, and we define it as this :

<example>Blast attribute = { 
    replication = -1,  
    protocol = ``bittorrent''
}
</example>

** Defining the tasks

Each tasks depends on two data : the Genebase data is a set of 3 compressed large files (1.7 GB), and the Sequence  which is the parameter of the task. The previous experience has shown that ftp is an appropriate protocol to distributes sequence which are small text files, unique to each tasks, and BitTorrent is efficient to distribute Genobase, composed of large files shared by a lot of nodes. We define an affinity between a Sequence and a Genobase, which means that BitDew will automatically schedule transfer of Genobase data wherever a Sequence is present. 

<example>
Genebase attribute = {
  protocol = ``bittorrent'',
  lifetime = Collector,
  affinity = Sequence
}

Sequence attribute = {
  fault-tolerance = true,
  protocol = ``http'',
  lifetime = Collector,
  replication = x
}
</example>

At the end of the computation, the tasks will produce a result file which has to be retreived by the master node. The master creates an empty data, a Collector and every slaves set an affinity attribute from a  Result data to a Collector data. By this way, every result will get automatically transfered to the master node. At the end of the experiment, it is wise to delete the data and to purge the local cache. However, some files are large and should be kept persistent on the local cache for the next execution. An elegant way is to use for every data a relative lifetime to the Collector. Once the user decides that he has finished his work, he can safely delete the Collector data, which will obsolete the others data.

<example>
Result attribute = {
  protocol = ``http'',
  affinity = Sequence,
  affinity = Collector,
  lifetime = Collector
}


Collector attribute {
}
</example>

Setting the fault-tolerant attribute for the sequence data ensures that the tasks will be rescheduled if the host failed. The replication attribute of the sequence also affects the scheduling of data and tasks on the hosts. For instance, to implement the scheduling strategy presented in \cite{derrick}, one would simply keep a replication to 1 when the number of tasks is less than the number of hosts and dynamically increase this replication attribute when there is more  hosts available than remaining tasks.



