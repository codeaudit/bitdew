package xtremweb.serv.dt.jsaga;

import java.util.Properties;

import org.ogf.saga.context.Context;
import org.ogf.saga.context.ContextFactory;
import org.ogf.saga.error.AlreadyExistsException;
import org.ogf.saga.error.AuthenticationFailedException;
import org.ogf.saga.error.AuthorizationFailedException;
import org.ogf.saga.error.BadParameterException;
import org.ogf.saga.error.DoesNotExistException;
import org.ogf.saga.error.IncorrectStateException;
import org.ogf.saga.error.IncorrectURLException;
import org.ogf.saga.error.NoSuccessException;
import org.ogf.saga.error.NotImplementedException;
import org.ogf.saga.error.PermissionDeniedException;
import org.ogf.saga.error.TimeoutException;
import org.ogf.saga.monitoring.Callback;
import org.ogf.saga.monitoring.Metric;
import org.ogf.saga.monitoring.Monitorable;
import org.ogf.saga.namespace.Flags;
import org.ogf.saga.namespace.NSEntry;
import org.ogf.saga.namespace.NSFactory;
import org.ogf.saga.session.Session;
import org.ogf.saga.session.SessionFactory;
import org.ogf.saga.task.Task;
import org.ogf.saga.task.TaskMode;
import org.ogf.saga.url.URL;
import org.ogf.saga.url.URLFactory;

import fr.in2p3.jsaga.adaptor.security.VOMSContext;
import xtremweb.core.conf.ConfigurationException;
import xtremweb.core.conf.ConfigurationProperties;
import xtremweb.core.obj.dc.Data;
import xtremweb.core.obj.dc.Locator;
import xtremweb.core.obj.dr.Protocol;
import xtremweb.core.obj.dt.Transfer;
import xtremweb.serv.dt.BlockingOOBTransferImpl;
import xtremweb.serv.dt.OOBException;

/**
 * This class allows Jsaga transfers between a local host and a production grid
 * 
 * @author josefrancisco
 */
public class JsagaTransfer extends BlockingOOBTransferImpl {

    private static final String OPT_HELP = "h", LONGOPT_HELP = "help";
    private static final String OPT_NOT_OVERWRITE = "i", LONGOPT_NOT_OVERWRITE = "interactive";
    private static final String OPT_RECURSIVE = "r", LONGOPT_RECURSIVE = "recursive";
    private static final String OPT_PRESERVE_TIMES = "p", LONGOPT_PRESERVE_TIMES = "preserve";
    private static final String OPT_MONITOR = "m", LONGOPT_MONITOR = "monitor";

    public JsagaTransfer(Data d, Transfer t, Locator rl, Locator ll, Protocol rp, Protocol lp) {
	super(d, t, rl, ll, rp, lp);
    }

    /**
     * JSaga Session
     */
    private Session session;

    /**
     * JSaga properties
     */
    private Properties mainprops;

    /**
     * Jsaga security context
     */
    private Context ctx;

    /**
     * Connect to the grid via a pre-defined proxy
     * @throws  
     */
    public void connect() throws OOBException {
	try {
	    mainprops = ConfigurationProperties.getProperties();
	
	ctx = ContextFactory.createContext();

	// Define the voms server
	ctx.setAttribute(Context.SERVER, mainprops.getProperty("xtremweb.serv.dr.jsaga.server"));

	// Define your VO
	ctx.setAttribute(Context.USERVO, mainprops.getProperty("xtremweb.serv.dr.jsaga.uservo"));

	// Define your proxy life time
	ctx.setAttribute(Context.LIFETIME, mainprops.getProperty("xtremweb.serv.dr.jsaga.lifetime"));

	// The path of the proxy generated by JSAGA
	ctx.setAttribute(Context.USERPROXY, mainprops.getProperty("xtremweb.serv.dr.jsaga.userproxy"));

	// The path of your user certificate
	ctx.setAttribute(Context.USERCERT, mainprops.getProperty("xtremweb.serv.dr.jsaga.usercert"));

	// The path of your user key
	ctx.setAttribute(Context.USERKEY, mainprops.getProperty("xtremweb.serv.dr.jsaga.userkey"));

	// The password of your user key
	ctx.setAttribute(Context.USERPASS, mainprops.getProperty("xtremweb.serv.dr.jsaga.userpass"));

	// A directory containing the CA certificates
	// (http://dist.eugridpma.info/distribution/igtf/current/accredited/tgz/)
	ctx.setAttribute(Context.CERTREPOSITORY, mainprops.getProperty("xtremweb.serv.dr.jsaga.certrepository"));

	// Needed ??? Might be leaved empty
	ctx.setAttribute(VOMSContext.VOMSDIR, mainprops.getProperty("xtremweb.serv.dr.jsaga.vomsdir"));

	ctx.setAttribute(Context.TYPE, mainprops.getProperty("xtremweb.serv.dr.jsaga.type"));

	session = SessionFactory.createSession(false);
	session.addContext(ctx);
	} catch (ConfigurationException e) {
	    e.printStackTrace();
	    throw new OOBException("ConfigurationException");
	} catch (IncorrectStateException e) {
	    e.printStackTrace();
	    throw new OOBException("IncorrectStateException");
	} catch (TimeoutException e) {
	    e.printStackTrace();
	    throw new OOBException("TimeoutException");
	} catch (NoSuccessException e) {
	    e.printStackTrace();
	    throw new OOBException("NoSuccessException");
	} catch (NotImplementedException e) {
	    e.printStackTrace();
	    throw new OOBException("NotImplementedException");
	} catch (AuthenticationFailedException e) {
	    e.printStackTrace();
	    throw new OOBException("AuthenticationFailedException");
	} catch (AuthorizationFailedException e) {
	    e.printStackTrace();
	    throw new OOBException("AuthorizationFailedException");
	} catch (PermissionDeniedException e) {
	    e.printStackTrace();
	    throw new OOBException("PermissionDeniedException");
	} catch (BadParameterException e) {
	    e.printStackTrace();
	    throw new OOBException("BadParemeterException");
	} catch (DoesNotExistException e) {
	    e.printStackTrace();
	    throw new OOBException("DoesNotExistException");
	}

    }

    /**
     * 
     */
    public void disconnect() throws OOBException {
	// TODO Auto-generated method stub

    }

    /**
     * 
     */
    public void blockingSendSenderSide() throws OOBException {

	LDAPInterface ldap = new JndiLdapImpl();
	try {
	    ldap.connect(mainprops.getProperty("xtremweb.serv.dt.jsaga.ldaphost"));
	    String urltarget = ldap.getGFTPEndpoint();
	    URL source = URLFactory.createURL("file://" + local_locator.getref());
	    URL target = URLFactory.createURL(urltarget);
	    int flags = Flags.OVERWRITE.or(((Flags.NONE).or(Flags.NONE.getValue())));
	    Session session = SessionFactory.createSession(true);
	    NSEntry entry = NSFactory.createNSEntry(session, source, Flags.NONE.getValue());
	    entry.copy(target, flags);
	    entry.close();
	} catch (LDAPEngineException e) {	    
	    e.printStackTrace();
	    throw new OOBException("LDAP engine exception");
	} catch (BadParameterException e) {	   
	    e.printStackTrace();
	    throw new OOBException("BadParameterException");
	} catch (NoSuccessException e) {	   
	    e.printStackTrace();
	    throw new OOBException("NoSuccessException");
	} catch (NotImplementedException e) {
	    
	    e.printStackTrace();
	    throw new OOBException("NotImplementedException");
	} catch (IncorrectURLException e) {
	    
	    e.printStackTrace();
	    throw new OOBException("IncorrectURLException");
	} catch (AuthenticationFailedException e) {
	   
	    e.printStackTrace();
	    throw new OOBException("AuthenticationFailedException");
	} catch (AuthorizationFailedException e) {
	    
	    e.printStackTrace();
	    throw new OOBException("AuthorizationFailedException");
	} catch (PermissionDeniedException e) {
	   
	    e.printStackTrace();
	    throw new OOBException("PermissionDeniedException");
	} catch (DoesNotExistException e) {	    
	    e.printStackTrace();
	    throw new OOBException("DoesNotExistException");
	} catch (AlreadyExistsException e) {
	    
	    e.printStackTrace();
	    throw new OOBException("AlreadyExistsException");
	} catch (TimeoutException e) {
	    
	    e.printStackTrace();
	    throw new OOBException("TimeoutException");
	} catch (IncorrectStateException e) {
	    
	    e.printStackTrace();
	    throw new OOBException("IncorrectStateException");
	}
    }

    /**
     * Due to the nature of a jsaga transfer this method is not necessary to
     * implement
     */
    public void blockingSendReceiverSide() throws OOBException {
    }

    /**
     * Due to the nature of a jsaga transfer this method is not necessary to
     * implement
     */
    public void blockingReceiveSenderSide() throws OOBException {
    }

    /**
     * 
     */
    public void blockingReceiveReceiverSide() throws OOBException {
	/*
	 * NSEntry entry = NSFactory.createNSEntry(session, source,
	 * Flags.NONE.getValue()); if (line.hasOption(OPT_MONITOR)) { Task task
	 * = entry.copy(TaskMode.TASK, target, flags); try { Metric metric =
	 * task.getMetric("file.copy.progress"); metric.addCallback(new
	 * Callback() { public boolean cb(Monitorable mt, Metric metric, Context
	 * ctx) throws NotImplementedException, AuthorizationFailedException {
	 * try { String value = metric .getAttribute(Metric.VALUE); String unit
	 * = metric.getAttribute(Metric.UNIT); System.out.println("Progress: " +
	 * value + " " + unit); } catch (NotImplementedException e) { throw e; }
	 * catch (AuthorizationFailedException e) { throw e; } catch (Exception
	 * e) { e.printStackTrace(); } // callback must stay registered return
	 * true; } }); } catch (DoesNotExistException e) { System.err
	 * .println("WARN: Monitoring is not supported for this kind of transfer"
	 * ); } task.run(); task.waitFor(); switch (task.getState()) { case
	 * DONE: System.out.println("File successfully copied !"); break;
	 * default: task.rethrow(); break; } } else { entry.copy(target, flags);
	 * } entry.close(); }
	 */

    }

}
